%{

open IMJEquiv
open Microsoft.FSharp.Text.Parsing

/// A `ParseError (s,l,c)` exception carries a message
/// about the nature of the error `s`, a line number `l`
/// and a column number `c`.
exception ParseError of String * Int32 * Int32

/// Given a parse state `p`, a message `s` and the item 
/// number `n` of where the error occurs in the currently 
/// parsed rule, `reportError p s n` throws a `ParseError`
/// exception reporting the message, line and column number
/// corresponding to the error.
let reportError (p: IParseState) (s: String) (n: Int) =
  let posn = p.InputStartPosition n
  raise (ParseError (s, posn.Line, posn.Column + 1))

%}

%start Term ITbl TyEnv TyTerm Store

%token SKIP LET IN WHILE DO RIGHTARROW EQUALS BACKSLASH INT TIMES
%token COMMA STOP COLON SEMICOLON LPAREN RPAREN PLUS EOF TSTYLE NULL
%token ASSN IF THEN ELSE NEW LBRACE RBRACE VOID LANGLE RANGLE
%token <String> ID IID
%token <Int32> NUM RID

%nonassoc letterm
%left PLUS COLON COMMA SEMICOLON STOP ASSN EQUALS
%nonassoc castterm
%nonassoc ifterm
%nonassoc doterm

%type <Term> Term
%type <ITbl> ITbl
%type <TyEnv> TyEnv
%type <TyEnv * Term> TyTerm
%type <Store> Store

%%

Term:
  | NULL                                            { Term.Null }
  | ID                                              { Term.BVar $1 }
  | NUM						                        { Term.Num $1 }
  | SKIP						                    { Term.Skip }
  | Term PLUS Term				                    { Term.Plus ($1, $3) }
  | Term PLUS Recover                               { reportError parseState "Expected term" 3 }
  | Term EQUALS Term				                { Term.Eq ($1, $3) }
  | Term EQUALS Recover                             { reportError parseState "Expected term" 3 }
  | Term SEMICOLON Term			                    { Term.Seq ($1, $3) }
  | Term SEMICOLON Recover                          { reportError parseState "Expected term" 3 }
  | IF Term THEN Term ELSE Term     %prec ifterm    { Term.Cond ($2, $4, $6) } 
  | IF Recover                                      { reportError parseState "Expected term for if guard" 2 }
  | IF Term Recover                                 { reportError parseState "Expected then" 3 }
  | IF Term THEN Recover                            { reportError parseState "Expected term for if true branch" 4 }
  | IF Term THEN Term Recover                       { reportError parseState "Expected else" 5 }
  | IF Term THEN Term ELSE Recover                  { reportError parseState "Expected term for if false branch" 6 }
  | Term STOP ID ASSN Term                          { Term.Assn ($1, $3, $5) }
  | Term STOP ID ASSN Recover                       { reportError parseState "Expected term" 3 }
  | Term STOP ID                                    { Term.Fld ($1, $3) }
  | Term STOP Recover                               { reportError parseState "Expected field or method identifer" 3 }
  | Term STOP ID LPAREN Args RPAREN                 { Term.Call ($1, $3, $5) }
  | LPAREN IID RPAREN Term          %prec castterm  { Term.Cast ($2, $4) }
  | LPAREN IID RPAREN Recover                       { reportError parseState "Expected term to be cast" 4 }
  | LET ID EQUALS Term IN Term      %prec letterm   { Term.Let ($2, $4, $6) }
  | LET ID EQUALS Term IN Recover                   { reportError parseState "Expected term for let body" 6 }
  | LET ID EQUALS Recover                           { reportError parseState "Expected term to be bound" 4 }
  | LET Recover                                     { reportError parseState "Expected identifier to bind to" 2 }
  | WHILE Term DO Term              %prec doterm    { Term.While ($2, $4) }
  | WHILE Recover                                   { reportError parseState "Expected term for loop guard" 2 }
  | WHILE Term Recover                              { reportError parseState "Expected do" 3 }
  | WHILE Term DO Recover                           { reportError parseState "Expected term for loop body" 4 }
  | NEW LBRACE NewExp RBRACE                        { Term.New $3 }
  | NEW Recover                                     { reportError parseState "Expected left brace" 2 }
  | NEW LBRACE NewExp Recover                       { reportError parseState "Expected right brace" 4 }
  | LPAREN Term RPAREN                              { $2 }

NewExp:
  | ID COLON IID SEMICOLON Methods                  { ($1, $3, $5) }
  | ID Recover                                      { reportError parseState "Expected colon" 2 }
  | ID COLON Recover                                { reportError parseState "Expected interface identifer" 3 }
  | ID COLON IID Recover                            { reportError parseState "Expected semicolon" 4 }

Method:
  | ID COLON BACKSLASH Params STOP Term             { { MethSpec.Name = $1; Vars = $4; Body = $6 } }
  | ID Recover                                      { reportError parseState "Expected colon" 2 }
  | ID COLON Recover                                { reportError parseState "Expected lambda expression" 3 }
  | ID COLON BACKSLASH Recover                      { reportError parseState "Expected parameter list" 4 }
  | ID COLON BACKSLASH Params Recover               { reportError parseState "Expected stop" 5 }
  | ID COLON BACKSLASH Params STOP Recover          { reportError parseState "Expected method body" 6 }
  | LPAREN Method RPAREN                            { $2 }

Methods:
  |                                                 { [] }
  | Method                                          { [$1] }
  | Method COMMA Methods1                           { $1 :: $3 }
  | Method COMMA Recover                            { reportError parseState "Expected method spec" 3 }

Methods1:
  | Method                                          { [$1] }
  | Method COMMA Methods1                           { $1 :: $3 }
  | Method COMMA Recover                            { reportError parseState "Expected method spec" 3 }

Params:
  | ID                                              { [$1] }
  | ID Params                                       { $1 :: $2 }

Args:
  |                                                 { [] }
  | Term                                            { [$1] }
  | Term COMMA Args1                                { $1 :: $3 }
  | Term COMMA Recover                              { reportError parseState "Expected argument" 3 }

Args1:
  | Term                                            { [$1] }
  | Term COMMA Args1                                { $1 :: $3 }
  | Term COMMA Recover                              { reportError parseState "Expected argument" 3 }

Type:
  | VOID                                            { Void }
  | INT                                             { Int }
  | IID                                             { Iface $1 }

TypeList:
  | Type                                            { [$1] }
  | Type COMMA TypeList                             { $1 :: $3 }

IDfn:
  | Type                                            { IFld $1 }
  | Type RIGHTARROW Type                            { IMth ([$1], $3) }
  | LPAREN TypeList RPAREN RIGHTARROW Type          { IMth ($2, $5) }

IDfnMap:
  | LBRACE IDfnMapContent RBRACE                    { $2 }

IDfnMapContent:
  |                                                 { Map.empty }
  | ID COLON IDfn                                   { Map.singleton $1 $3 }
  | ID COLON IDfn COMMA IDfnMapContent1             { Map.add $1 $3 $5 }

IDfnMapContent1:
  | ID COLON IDfn                                   { Map.singleton $1 $3 }
  | ID COLON IDfn COMMA IDfnMapContent1             { Map.add $1 $3 $5 }

ITblDfn:
  | IID EQUALS IDfnMap                              { ($1, Eqn $3) }
  | IID LANGLE IID RANGLE EQUALS IDfnMap            { ($1, Ext ($3,$6)) } 

ITbl:
  |                                                 { Map.empty }
  | ITblDfn                                         { Map.singleton (fst $1) (snd $1) }
  | ITblDfn COMMA ITbl1                             { Map.add (fst $1) (snd $1) $3 }

ITbl1:
  | ITblDfn                                         { Map.singleton (fst $1) (snd $1) }
  | ITblDfn COMMA ITbl1                             { Map.add (fst $1) (snd $1) $3 }

StoreFldsMap:
  | LBRACE StoreFldsMapContent RBRACE               { $2 }

StoreFldsMapContent:
  |                                                 { Map.empty }
  | ID EQUALS Val                                   { Map.singleton $1 $3 }
  | ID EQUALS Val COMMA StoreFldsMapContent1        { Map.add $1 $3 $5 }

StoreFldsMapContent1:
  | ID EQUALS Val                                   { Map.singleton $1 $3 }
  | ID EQUALS Val COMMA StoreFldsMapContent1        { Map.add $1 $3 $5 }

StoreItem:
  | RID COLON IID EQUALS StoreFldsMap               { ($1, ($3, $5)) }

Store:
  |                                                 { Map.empty }
  | StoreItem                                       { Map.singleton (fst $1) (snd $1) }
  | StoreItem COMMA Store1                          { Map.add (fst $1) (snd $1) $3 }

Store1:
  | StoreItem                                       { Map.singleton (fst $1) (snd $1) }
  | StoreItem COMMA Store1                          { Map.add (fst $1) (snd $1) $3 }

Val:
  | TIMES                                           { VStar }
  | RID                                             { VReg $1 }
  | NUM                                             { VNum $1 }
  | NULL                                            { VNul }

TyEnv:
  |                                                 { [] }
  | ID COLON Type                                   { [($1, $3)] }
  | ID COLON Type COMMA TyEnv                       { ($1, $3) :: $5 }

TyTerm:
  | TyEnv TSTYLE Term                               { ($1, $3) }

Recover:
  | error                                           { true }
  | EOF                                             { false }