/****************************************************************************/
/* Procedures related to configurations and witness recovery.		    */

#include "wpdsInt.h"

/**************************** INTERNAL FUNCTIONS ****************************/

/* Auxiliary hash functions. */
int wPathCompare (void *vp1, void *vp2)
{
	wPath *p1 = vp1, *p2 = vp2;

	if (p1->wnode > p2->wnode) return 1;
	if (p1->wnode < p2->wnode) return -1;
	if (p1->next_path > p2->next_path) return 1;
	if (p1->next_path < p2->next_path) return -1;
	return 0;
}

/* This function deletes a path element. It can be called in two contexts
   - by wPathDeref (when it is no longer referenced), or when the respective
   FA is deleted, and the path hash is destroyed. In the latter case, we're
   deleting everything anyway, so we don't dereference other paths. */
void wPathDelete (wFA *fa, wPath *p, char path_deref)
{
	wPathTrans *tmp;

	if (p->wnode) wWNDeref(fa,p->wnode);
	fa->sr->deref(p->value);

	while (p->transitions)
	{
		tmp = p->transitions;
		p->transitions = p->transitions->next;
		if (path_deref) wPathDeref(fa,tmp->target);
		Free(tmp);
	}

	if (path_deref) wPathDeref(fa,p->next_path);
	Free(p);
}

void wPathDeleteHash (void *vp)
{
	extern wFA *tmpFA;
	wPathDelete(tmpFA,vp,0);
}

/* Generate an 'anchor' struct. */
wPath* wPathAnchor (wFA *fa)
{
	wPath *newpath = Calloc(1,sizeof(struct wPath));
	newpath->value = fa->sr->zero();
	newpath->refcount = 1;
	return newpath;
}

/* Add a transition between two paths and reference the target. */
void wPathAddTrans (wFA *fa, wPath *from, wRule *rule, wPath *to)
{
	wPathTrans *tr = Malloc(sizeof(struct wPathTrans));

	tr->target = to;
	tr->rule = rule;
	tr->next = from->transitions;
	from->transitions = tr;
	wPathRef(fa,tr->target);
}

/* Like wPathAddTrans, but add at the end of the list. eol points to
   the "next" pointer of the last element. Its contents are overwritten
   by this function, and *eol is updated to point to the new end pointer. */
void wPathAppendTrans (wFA *fa, wPathTrans ***eol, wRule *rule, wPath *to)
{
	wPathTrans *tr = Malloc(sizeof(struct wPathTrans));

	tr->target = to;
	tr->rule = rule;
	tr->next = NULL;
	**eol = tr;
	*eol = &(tr->next);
	wPathRef(fa,tr->target);
}

/* Generate a wPath struct, or return an existing struct from the hash.
   The resulting path starts with wnode and continues with the sequence
   at next_path. Creates a reference to the resulting struct, and to
   next_path (if appropriate). */
wPath* wPathInsert (wFA *fa, wWitnessNode *wnode, wPath *next_path)
{
	wPath *path, *newpath;

	newpath = Calloc(1,sizeof(struct wPath));
	newpath->hash = (((int) wnode) >> 3) ^ ((int) next_path);
	wWNRef(fa,newpath->wnode = wnode);
	newpath->next_path = next_path;

	path = wHashInsert(fa->paths,newpath);

	if (path != newpath)	/* newpath already in hash; reuse path */
	{
		wWNDeref(fa,wnode);
		Free(newpath);
		wPathRef(fa,path);
	}
	else
	{
		wSRvalue d;

		if (next_path)
			fa->sr->ref(d = next_path->value);
		else
			d = fa->sr->one();

		path->value = (fa->dir == SAT_POST)
			? fa->sr->extend(d,wnode->value)
			: fa->sr->extend(wnode->value,d);
		fa->sr->deref(d);
		path->refcount = 1;

		wPathRef(fa,next_path);
	}
	return path;
}

/****************************************************************************/
/* wcFind and wcValue do the main part of the work for wPathFind and
   wPathValue; both rely on the hash table generated by wcSortTrans.
   The latter sets up a dummy sat process with a head table in which
   automaton transitions are indexed by source state and name. */

wSat* wcSortTransitions (wFA *fa)
{
	wSat *prcs = wSatCreate(fa->sr,fa->dir,0);
	wTrans *t;

	for (t = fa->transitions; t; t = t->next)
	{
		wHead *head = wHTInsert(prcs->heads,t->from,t->name);
		t->stack_prev = NULL;
		wHeadInsertTrans(head,t);
	}
	return prcs;
}

/* Recursively find the accepting paths for <p,contents of stack>. */
wPath* wcFind (wSat *prcs, wFA *fa, wIdent p, wIdent *stack)
{
	wHead *head = wHTInsert(prcs->heads,p,*stack);
	wPath *result, *continuations, *newconfig;
	wPathTrans *ct;
	wSRvalue *nv;
	wTrans *t;

	result = wPathAnchor(fa);

	if (!*stack)	/* return 1 if configuration ends at a final state */
	{
		if (!wIsFinal(p)) return result;
		fa->sr->deref(result->value);
		result->value = fa->sr->one();
		wPathAddTrans(fa,result,NULL,NULL);
		return result;
	}

	/* for all transitions (p,y,q), where y is the first stack symbol */
	for (t = head->trans; t; t = t->stack)
	{
		/* recursively compute the value for the rest of the path.. */
		continuations = wcFind(prcs,fa,t->to,stack+1);

		for (ct = continuations->transitions; ct; ct = ct->next)
		{
			newconfig = wPathInsert(fa,t->wnode,ct->target);
			wPathAddTrans(fa,result,NULL,newconfig);
			wPathDeref(fa,newconfig);

			nv = fa->sr->combine(result->value,newconfig->value);
			fa->sr->deref(result->value);
			result->value = nv;
		}

		wPathDeref(fa,continuations);
	}

	return result;
}

/* Recursively compute the value for <p,contents of stack>. */
wSRvalue wcValue (wSat *prcs, wIdent p, wIdent *stack)
{
	wSRvalue result = prcs->sr->zero(), nv, rv, nr;
	wHead *head = wHTInsert(prcs->heads,p,*stack);
	wTrans *t;

	if (!*stack)	/* return 1 if configuration ends at a final state */
	{
		if (wIsFinal(p))
		{
			prcs->sr->deref(result); 
			result = prcs->sr->one();
		}
		return result;
	}

	/* for all transitions (p,y,q), where y is the first stack symbol */
	for (t = head->trans; t; t = t->stack)
	{
		/* recursively compute the value for the rest of the path.. */
		rv = wcValue(prcs,t->to,stack+1);
		nv = (prcs->dir == SAT_POST)? prcs->sr->extend(rv,t->label)
					    : prcs->sr->extend(t->label,rv);
		/* ... and combine the result with the previous value */
		prcs->sr->deref(rv);
		nr = prcs->sr->combine(result,nv);
		prcs->sr->deref(nv);
		prcs->sr->deref(result);
		result = nr;
	}

	return result;
}

/****************************************************************************/

/* Auxiliary function for wPathTraceStep: computes a (direct) successor of
   'path'. 'mid' is either the same as path or is reachable from path
   with a "null" rule (this may happen in post*). 'edge' is an edge of the
   graph G_pop/G_push whose source is mid.

   New successors are appended to the list. The end of the list is marked
   by the pointer at **eol, and *eol is updated whenever a new successor
   is added.
*/
void wcExpandEdge (wFA *fa, wPath *path, wPath *mid,
			wWitnessEdge *edge, wPathTrans ***eol)
{
	wPath *newpath, *tmp;
	wWitnessNode *nn;
	wWitnessEdge *ne;

	/* Replace first transition in mid by the (up to two) transitions
	   mentioned in the edge. */
	wPathRef(fa,newpath = mid->next_path);

	if (edge->target2)
	{
		tmp = wPathInsert(fa,edge->target2,newpath);
		wPathDeref(fa,newpath);
		newpath = tmp;
	}
	if (edge->target1)
	{
		tmp = wPathInsert(fa,edge->target1,newpath);
		wPathDeref(fa,newpath);
		newpath = tmp;
	}

	/* If the result is the empty path, then path corresponds to an
	   initial configuration, and we're done. Otherwise, we're done
	   if we've made a non-"null" step. */
	if (!newpath || edge->rule)
	{
		wPathAppendTrans(fa,eol,edge->rule,newpath);
	}
	else
		/* We've made a "null" step, so we need to check out the
		   successors of 'newpath'. */
		for (nn = newpath->wnode; nn; nn = nn->previous)
		    for (ne = nn->edges; ne; ne = ne->next)
			wcExpandEdge(fa,path,newpath,ne,eol);

	wPathDeref(fa,newpath);
}


/**************************** EXTERNAL FUNCTIONS ****************************/

wConfig* wConfigCreate (wIdent p, wIdent y1, ...)
{
	wConfig *config = Malloc(sizeof(struct wConfig));
	wIdent stacksymbol = y1, *sptr;
	int stacklength = 1;
	va_list args;

	config->state = p;

	/* Determine length of configuration */
	va_start(args,y1);
	while (stacksymbol)
	{
		stacksymbol = va_arg(args,wIdent);
		stacklength++;
	}
	va_end(args);

	/* Store the given stack symbols into an array */
	config->stack = sptr = Calloc(stacklength,sizeof(wIdent));
	stacksymbol = y1;
	va_start(args,y1);
	while (stacksymbol)
	{
		*sptr++ = stacksymbol;
		stacksymbol = va_arg(args,wIdent);
	}
	va_end(args);

	return config;
}

wConfig* wConfigCopy (wConfig *config)
{
	wConfig *nc = Malloc(sizeof(struct wConfig));
	wIdent *sptr = config->stack;

	int stacklength = 1;
	while (*sptr++) stacklength++;

	nc->state = config->state;
	nc->stack = Calloc(stacklength,sizeof(wIdent));
	memcpy(nc->stack,config->stack,stacklength * sizeof(wIdent));

	return nc;
}

void wConfigDelete (wConfig *config)
{
	Free(config->stack);
	Free(config);
}

wSRvalue wConfigValue (wFA *fa, wConfig *config)
{
	wSat *prcs = wcSortTransitions(fa);
	wSRvalue result = wcValue(prcs,config->state,config->stack);
	wFADelete(wSatDelete(prcs));

	return result;
}

/****************************************************************************/

wPath* wPathFind (wFA *fa, wConfig *config)
{
	wPath *path;
	wSat *prcs = wcSortTransitions(fa);

	if (!fa->paths) fa->paths = wHashCreate(wPathCompare);
	path = wcFind(prcs,fa,config->state,config->stack);
	wFADelete(wSatDelete(prcs));

	return path;
}

wPath *wPathFromArray (wFA *fa, wTrans **transitions)
{
	wPath *result = NULL, *newresult;
	wTrans **tptr = transitions-1;

	if (!fa->paths) fa->paths = wHashCreate(wPathCompare);

	while (*++tptr);	/* find end of array */
	do {			/* build path from back to front */
		newresult = wPathInsert(fa,(*--tptr)->wnode,result);
		wPathDeref(fa,result);
		result = newresult;
	} while (tptr > transitions);

	return result;
}

wPath* wPathCreate (wFA *fa, wTrans *t1, ...)
{
	wTrans **transitions, **tptr, *trans = t1;
	wPath *result;
	int conflength = 0;
	va_list args;

	/* Determine length of configuration */
	va_start(args,t1);
	while (trans)
	{
		trans = va_arg(args,wTrans*);
		conflength++;
	}
	va_end(args);

	/* Copy arguments into an array */
	tptr = transitions = Calloc(conflength + 1,sizeof(wTrans*));
	trans = t1;
	va_start(args,t1);
	while (trans)
	{
		*tptr++ = trans;
		trans = va_arg(args,wTrans*);
	}
	va_end(args);

	/* Now create the path */
	result = wPathFromArray(fa,transitions);

	/* Clean up and return. */
	Free(transitions);

	return result;
}

wConfig* wPathConfig (wFA *fa, wPath *path)
{
	wPath *tmp;
	wConfig *config;
	int pathlength = 1;
	wIdent *sptr;

	for (tmp = path; tmp; tmp = tmp->next_path) pathlength++;
	config = Malloc(sizeof(struct wConfig));
	config->state = path? path->wnode->trans->from : 0;
	config->stack = sptr = Calloc(pathlength,sizeof(wIdent));
	for (tmp = path; tmp; tmp = tmp->next_path)
		*sptr++ = tmp->wnode->trans->name;

	return config;
}

void wPathRef (wFA *fa, wPath *c)
{
	if (!c) return;
	c->refcount++;
}

void wPathDeref (wFA *fa, wPath *c)
{
	if (!c) return;
	if (--c->refcount) return;
	if (c->wnode) wHashRemove(fa->paths,c);
	wPathDelete(fa,c,1);
}

void wPathTraceStep (wFA *fa, wPath *path)
{
	wWitnessNode *node;
	wWitnessEdge *edge;
	wPathTrans **eol;

	if (!path || path->transitions) return;

	/* We can assume path->transitions == NULL here, i.e. the
	   list of successors is empty. */
	eol = &(path->transitions);

	for (node = path->wnode; node; node = node->previous)
		for (edge = node->edges; edge; edge = edge->next)
			wcExpandEdge(fa,path,path,edge,&eol);
}

void wPathTraceAll (wFA *fa, wPath *path)
{
	wPathTrans *pt;

	if (!path || path->transitions) return;
	wPathTraceStep(fa,path);
	for (pt = path->transitions; pt; pt = pt->next)
		wPathTraceAll(fa,pt->target);
}
